# Generated by Django 3.0 on 2020-01-13 10:54

from django.conf import settings
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import fernet_fields.fields
import orchestrator.models
import simple_history.models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='App',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Specify the name of the application.', max_length=255, unique=True)),
                ('path', models.CharField(help_text='Specify the path to the application.', max_length=255)),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='Bot',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Specify the name of the bot.', max_length=255, unique=True)),
                ('computer_name', models.CharField(default=orchestrator.models.get_computer_name, help_text='Specify the computer name of the bot.', max_length=255)),
                ('user_name', models.CharField(default=orchestrator.models.get_user_name, help_text='Specify the username of the bot.', max_length=255)),
                ('nintex_rpa_license_path', models.CharField(blank=True, default='', help_text='Specify the Nintex RPA license path of the bot. If the field is blank there will be no check to ensure the availability of licenses. IMPORTANT: Only applies to the Concurrent Edition license model.', max_length=255, verbose_name='License path')),
                ('nintex_rpa_available_foxtrot_licenses', models.PositiveIntegerField(default=0, help_text='Specify the total number of available Foxtrot licenses in the path. IMPORTANT: Only applies to the Concurrent Edition license model.', verbose_name='Available Foxtrot licenses')),
                ('nintex_rpa_available_foxbot_licenses', models.PositiveIntegerField(default=0, help_text='Specify the total number of available FoxBot licenses in the path. IMPORTANT: Only applies to the Concurrent Edition license model.', verbose_name='Available FoxBot licenses')),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='Botflow',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Specify the name of the botflow/script/file.', max_length=255, unique=True)),
                ('path', models.CharField(help_text='Specify the path to the botflow/script/file.', max_length=255)),
                ('queue_if_already_running', models.BooleanField(default=True, help_text="Specify whether the botflow should be added to the queue if this botflow is already in the queue as either 'Pending' or 'Running'.")),
                ('priority', models.PositiveIntegerField(default=3, help_text='Specify the priority of the triggered botflow (1 is highest, 5 is lowest). The triggered botflow with the highest priority will always run first.', validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(5)])),
                ('timeout_minutes', models.PositiveIntegerField(default=300, help_text='Specify after how many minutes the botflow process should be forcibly killed.', validators=[django.core.validators.MinValueValidator(1)])),
                ('timeout_kill_processes', models.CharField(blank=True, help_text="Specify any additional processes that should be killed in the event of a timeout. To specify multiple processes, use comma to separate them like this: 'iexplore.exe, explorer.exe'.", max_length=255)),
                ('queued_notification', models.CharField(blank=True, help_text="Specify who (if any) should receive an email notification when the botflow is queued. To specify multiple emails, use comma to separate them like this: 'abc@basico.dk, xyz@basico.dk'.", max_length=255)),
                ('started_notification', models.CharField(blank=True, help_text="Specify who (if any) should receive an email notification when the botflow is started. To specify multiple emails, use comma to separate them like this: 'abc@basico.dk, xyz@basico.dk'.", max_length=255)),
                ('completed_notification', models.CharField(blank=True, help_text="Specify who (if any) should receive an email notification when the botflow is completed. To specify multiple emails, use comma to separate them like this: 'abc@basico.dk, xyz@basico.dk'.", max_length=255)),
                ('error_notification', models.CharField(blank=True, help_text="Specify who (if any) should receive an email notification when the botflow fails. To specify multiple emails, use comma to separate them like this: 'abc@basico.dk, xyz@basico.dk'. IMPORTANT: This will not include errors during the execution of the botflow.", max_length=255)),
                ('close_bot_automatically', models.BooleanField(default=False, help_text='Specify whether to automatically close the bot using the /Close /Exit commands. IMPORTANT: This is a Nintex RPA specific setting.')),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='BotflowExecution',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('time_queued', models.DateTimeField(auto_now_add=True)),
                ('app', models.CharField(max_length=255)),
                ('botflow', models.CharField(max_length=255)),
                ('trigger', models.CharField(max_length=255)),
                ('computer_name', models.CharField(max_length=255)),
                ('user_name', models.CharField(max_length=255)),
                ('priority', models.PositiveIntegerField(validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(5)])),
                ('status', models.CharField(max_length=255)),
                ('timeout_minutes', models.PositiveIntegerField(validators=[django.core.validators.MinValueValidator(1)])),
                ('timeout_kill_processes', models.CharField(blank=True, max_length=255)),
                ('queued_notification', models.CharField(blank=True, max_length=255)),
                ('started_notification', models.CharField(blank=True, max_length=255)),
                ('completed_notification', models.CharField(blank=True, max_length=255)),
                ('error_notification', models.CharField(blank=True, max_length=255)),
                ('close_bot_automatically', models.BooleanField(default=False)),
                ('nintex_rpa_license_path', models.CharField(max_length=255)),
                ('nintex_rpa_available_foxtrot_licenses', models.PositiveIntegerField()),
                ('nintex_rpa_available_foxbot_licenses', models.PositiveIntegerField()),
                ('time_start', models.DateTimeField(blank=True, null=True)),
                ('time_end', models.DateTimeField(blank=True, null=True)),
            ],
        ),
        migrations.CreateModel(
            name='PythonFunction',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Specify the name of the Python function.', max_length=255, unique=True)),
                ('description', fernet_fields.fields.EncryptedTextField(help_text='Specify a description of the Python function.')),
                ('encrypted_value_1', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_1' variable.", max_length=255)),
                ('encrypted_value_2', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_2' variable.", max_length=255)),
                ('encrypted_value_3', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_3' variable.", max_length=255)),
                ('encrypted_value_4', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_4' variable.", max_length=255)),
                ('encrypted_value_5', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_5' variable.", max_length=255)),
                ('code', fernet_fields.fields.EncryptedTextField(default='## This is some descriptive code to help you use the Python function.\n## Simple calculation example :\n# x = int(input)\n# y = 5\n# output = x * 5\n## The returned response for this function will be:\n# \'{"output": X}\'\n## -----------------------------------------------------------------------------------------------------------\n## Simple SMTP example:\n# from smtplib import SMTP, SMTP_SSL\n# from email.message import EmailMessage\n# msg = EmailMessage()\n# msg[\'Subject\'] = "Testing SMTP"\n# msg[\'From\'] = input\n# msg[\'To\'] = input\n# with SMTP("smtp.office365.com", 587) as server:\n#   server.starttls()\n#   server.login(input, encrypted_value_1)\n#   server.send_message(msg)\n# output = "Email sent successfully!"\n## The returned response for this function will be:\n# \'{"output": "Email sent successfully!"}\'', help_text="Specify the code of the Python function. To retrieve the input served by the API call, reference the 'input' variable. The value of the variable 'output' will be returned in the API response.")),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='SmtpAccount',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('email', models.EmailField(help_text='Specify the email of the SMTP account.', max_length=254, unique=True)),
                ('password', fernet_fields.fields.EncryptedCharField(help_text='Specify the password of the SMTP account.', max_length=255)),
                ('server', models.CharField(help_text='Specify the server of the SMTP account. For example: smtp.office365.com', max_length=255)),
                ('port', models.PositiveIntegerField(help_text='Specify the port of the SMTP account. For example: 587')),
                ('tls', models.BooleanField(default=True, help_text="Specify whether the SMTP account requires 'SSL/TLS'.", verbose_name='SSL/TLS')),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the SMTP account should be active.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the SMTP account.', max_length=255)),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'SMTP account',
                'verbose_name_plural': 'SMTP accounts',
            },
        ),
        migrations.CreateModel(
            name='ScheduleTrigger',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('frequency', models.CharField(choices=[('MIN', 'Minute'), ('HOU', 'Hour'), ('DAY', 'Day'), ('WEE', 'Week'), ('MON', 'Month'), ('FWK', 'First Week Day'), ('FWD', 'First Weekend Day'), ('LWK', 'Last Week Day'), ('LWD', 'Last Weekend Day')], help_text='Specify the frequency of the trigger.', max_length=3)),
                ('run_every', models.PositiveIntegerField(help_text='Specify how often to run every minute/hour/day/week.', validators=[django.core.validators.MinValueValidator(1)])),
                ('run_start', models.DateTimeField(help_text='Specify the start date and time for the trigger. This will be the starting point of the trigger.')),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('run_after', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active after this time.', null=True)),
                ('run_until', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active before this time.', null=True)),
                ('run_on_week_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on week days.')),
                ('run_on_weekend_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on weekend days.')),
                ('next_execution', models.CharField(blank=True, editable=False, help_text='This field specifies the scheduled time for the next execution. IMPORTANT: This date and time field is in UTC timezone, therefore, an offset is expected!', max_length=255)),
                ('past_settings', models.CharField(blank=True, max_length=255)),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
                ('app', models.ForeignKey(help_text='Select the application for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.App')),
                ('bot', models.ForeignKey(help_text='Select the bot for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(help_text='Select the botflow for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Botflow')),
            ],
        ),
        migrations.CreateModel(
            name='PythonFunctionExecution',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('request_ip', fernet_fields.fields.EncryptedCharField(max_length=255)),
                ('input', fernet_fields.fields.EncryptedTextField()),
                ('output', fernet_fields.fields.EncryptedTextField()),
                ('code', fernet_fields.fields.EncryptedTextField()),
                ('time_start', models.DateTimeField(blank=True, null=True)),
                ('time_end', models.DateTimeField(blank=True, null=True)),
                ('python_function', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to='orchestrator.PythonFunction')),
                ('request_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='HistoricalSmtpAccount',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('email', models.EmailField(db_index=True, help_text='Specify the email of the SMTP account.', max_length=254)),
                ('password', fernet_fields.fields.EncryptedCharField(help_text='Specify the password of the SMTP account.', max_length=255)),
                ('server', models.CharField(help_text='Specify the server of the SMTP account. For example: smtp.office365.com', max_length=255)),
                ('port', models.PositiveIntegerField(help_text='Specify the port of the SMTP account. For example: 587')),
                ('tls', models.BooleanField(default=True, help_text="Specify whether the SMTP account requires 'SSL/TLS'.", verbose_name='SSL/TLS')),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the SMTP account should be active.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the SMTP account.', max_length=255)),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical SMTP account',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalScheduleTrigger',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('frequency', models.CharField(choices=[('MIN', 'Minute'), ('HOU', 'Hour'), ('DAY', 'Day'), ('WEE', 'Week'), ('MON', 'Month'), ('FWK', 'First Week Day'), ('FWD', 'First Weekend Day'), ('LWK', 'Last Week Day'), ('LWD', 'Last Weekend Day')], help_text='Specify the frequency of the trigger.', max_length=3)),
                ('run_every', models.PositiveIntegerField(help_text='Specify how often to run every minute/hour/day/week.', validators=[django.core.validators.MinValueValidator(1)])),
                ('run_start', models.DateTimeField(help_text='Specify the start date and time for the trigger. This will be the starting point of the trigger.')),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('run_after', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active after this time.', null=True)),
                ('run_until', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active before this time.', null=True)),
                ('run_on_week_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on week days.')),
                ('run_on_weekend_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on weekend days.')),
                ('next_execution', models.CharField(blank=True, editable=False, help_text='This field specifies the scheduled time for the next execution. IMPORTANT: This date and time field is in UTC timezone, therefore, an offset is expected!', max_length=255)),
                ('past_settings', models.CharField(blank=True, max_length=255)),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('app', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the application for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.App')),
                ('bot', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the bot for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the botflow for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Botflow')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical schedule trigger',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalPythonFunction',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('name', models.CharField(db_index=True, help_text='Specify the name of the Python function.', max_length=255)),
                ('description', fernet_fields.fields.EncryptedTextField(help_text='Specify a description of the Python function.')),
                ('encrypted_value_1', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_1' variable.", max_length=255)),
                ('encrypted_value_2', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_2' variable.", max_length=255)),
                ('encrypted_value_3', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_3' variable.", max_length=255)),
                ('encrypted_value_4', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_4' variable.", max_length=255)),
                ('encrypted_value_5', fernet_fields.fields.EncryptedCharField(blank=True, help_text="Specify an optional encrypted value to use in the Python function. To retrieve the value in the code, reference the 'encrypted_value_5' variable.", max_length=255)),
                ('code', fernet_fields.fields.EncryptedTextField(default='## This is some descriptive code to help you use the Python function.\n## Simple calculation example :\n# x = int(input)\n# y = 5\n# output = x * 5\n## The returned response for this function will be:\n# \'{"output": X}\'\n## -----------------------------------------------------------------------------------------------------------\n## Simple SMTP example:\n# from smtplib import SMTP, SMTP_SSL\n# from email.message import EmailMessage\n# msg = EmailMessage()\n# msg[\'Subject\'] = "Testing SMTP"\n# msg[\'From\'] = input\n# msg[\'To\'] = input\n# with SMTP("smtp.office365.com", 587) as server:\n#   server.starttls()\n#   server.login(input, encrypted_value_1)\n#   server.send_message(msg)\n# output = "Email sent successfully!"\n## The returned response for this function will be:\n# \'{"output": "Email sent successfully!"}\'', help_text="Specify the code of the Python function. To retrieve the input served by the API call, reference the 'input' variable. The value of the variable 'output' will be returned in the API response.")),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical python function',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalFileTrigger',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('folder_in', models.CharField(help_text='Specify the folder for incoming files. When a file is detected in this folder, the trigger will be activated.', max_length=255)),
                ('folder_out', models.CharField(help_text='Specify the folder that the files should be moved to. When the trigger is activated, the file will be moved to this folder.', max_length=255)),
                ('filter', models.CharField(default='*', help_text="Specify any filter to only trigger on certain files. The default value '*' means all files. To specify multiple filters, use comma to separate them like this: '*.txt, *.pdf'.", max_length=255)),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('run_after', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active after this time.', null=True)),
                ('run_until', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active before this time.', null=True)),
                ('run_on_week_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on week days.')),
                ('run_on_weekend_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on weekend days.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('app', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the application for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.App')),
                ('bot', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the bot for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the botflow for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Botflow')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical file trigger',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalEmailOutlookTrigger',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('email', models.CharField(default='Default', help_text="Specify the email of the account to monitor. IMPORTANT: If you wish to monitor the primary Outlook account, the email should be set to 'Default'.", max_length=255)),
                ('folder_in', models.CharField(help_text="Specify the folder for incoming emails. When an email is detected in this folder, the trigger will be activated. The folder must be in the 'INBOX'. To specify subfolders, use slash to separate the folder names like this: Invoices/Incoming", max_length=255)),
                ('folder_out', models.CharField(help_text="Specify the folder that the emails should be moved to. When the trigger is activated, the email will be moved to this folder. The folder must be in the 'INBOX'. To specify subfolders, use slash to separate the folder names like this: Invoices/Incoming/Handled", max_length=255)),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('run_after', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active after this time.', null=True)),
                ('run_until', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active before this time.', null=True)),
                ('run_on_week_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on week days.')),
                ('run_on_weekend_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on weekend days.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('app', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the application for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.App')),
                ('bot', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the bot for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the botflow for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Botflow')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical Email Outlook trigger',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalEmailImapTrigger',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('email', models.EmailField(help_text='Specify the email of the IMAP account.', max_length=254)),
                ('password', fernet_fields.fields.EncryptedCharField(help_text='Specify the password of the IMAP account.', max_length=255)),
                ('server', models.CharField(help_text='Specify the server of the IMAP account. For example: outlook.office365.com', max_length=255)),
                ('port', models.PositiveIntegerField(help_text='Specify the port of the IMAP account. For example: 993')),
                ('tls', models.BooleanField(default=True, help_text="Specify whether the IMAP account requires 'SSL/TLS'.", verbose_name='SSL/TLS')),
                ('folder_in', models.CharField(help_text="Specify the folder for incoming emails. When an email is detected in this folder, the trigger will be activated. The folder must be in the 'INBOX'. To specify subfolders, use slash to separate the folder names like this: Invoices/Incoming", max_length=255)),
                ('folder_out', models.CharField(help_text="Specify the folder that the emails should be moved to. When the trigger is activated, the email will be moved to this folder. The folder must be in the 'INBOX'. To specify subfolders, use slash to separate the folder names like this: Invoices/Incoming/Handled", max_length=255)),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('run_after', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active after this time.', null=True)),
                ('run_until', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active before this time.', null=True)),
                ('run_on_week_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on week days.')),
                ('run_on_weekend_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on weekend days.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('app', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the application for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.App')),
                ('bot', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the bot for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the botflow for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Botflow')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical Email IMAP trigger',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalBotflow',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('name', models.CharField(db_index=True, help_text='Specify the name of the botflow/script/file.', max_length=255)),
                ('path', models.CharField(help_text='Specify the path to the botflow/script/file.', max_length=255)),
                ('queue_if_already_running', models.BooleanField(default=True, help_text="Specify whether the botflow should be added to the queue if this botflow is already in the queue as either 'Pending' or 'Running'.")),
                ('priority', models.PositiveIntegerField(default=3, help_text='Specify the priority of the triggered botflow (1 is highest, 5 is lowest). The triggered botflow with the highest priority will always run first.', validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(5)])),
                ('timeout_minutes', models.PositiveIntegerField(default=300, help_text='Specify after how many minutes the botflow process should be forcibly killed.', validators=[django.core.validators.MinValueValidator(1)])),
                ('timeout_kill_processes', models.CharField(blank=True, help_text="Specify any additional processes that should be killed in the event of a timeout. To specify multiple processes, use comma to separate them like this: 'iexplore.exe, explorer.exe'.", max_length=255)),
                ('queued_notification', models.CharField(blank=True, help_text="Specify who (if any) should receive an email notification when the botflow is queued. To specify multiple emails, use comma to separate them like this: 'abc@basico.dk, xyz@basico.dk'.", max_length=255)),
                ('started_notification', models.CharField(blank=True, help_text="Specify who (if any) should receive an email notification when the botflow is started. To specify multiple emails, use comma to separate them like this: 'abc@basico.dk, xyz@basico.dk'.", max_length=255)),
                ('completed_notification', models.CharField(blank=True, help_text="Specify who (if any) should receive an email notification when the botflow is completed. To specify multiple emails, use comma to separate them like this: 'abc@basico.dk, xyz@basico.dk'.", max_length=255)),
                ('error_notification', models.CharField(blank=True, help_text="Specify who (if any) should receive an email notification when the botflow fails. To specify multiple emails, use comma to separate them like this: 'abc@basico.dk, xyz@basico.dk'. IMPORTANT: This will not include errors during the execution of the botflow.", max_length=255)),
                ('close_bot_automatically', models.BooleanField(default=False, help_text='Specify whether to automatically close the bot using the /Close /Exit commands. IMPORTANT: This is a Nintex RPA specific setting.')),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical botflow',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalBot',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('name', models.CharField(db_index=True, help_text='Specify the name of the bot.', max_length=255)),
                ('computer_name', models.CharField(default=orchestrator.models.get_computer_name, help_text='Specify the computer name of the bot.', max_length=255)),
                ('user_name', models.CharField(default=orchestrator.models.get_user_name, help_text='Specify the username of the bot.', max_length=255)),
                ('nintex_rpa_license_path', models.CharField(blank=True, default='', help_text='Specify the Nintex RPA license path of the bot. If the field is blank there will be no check to ensure the availability of licenses. IMPORTANT: Only applies to the Concurrent Edition license model.', max_length=255, verbose_name='License path')),
                ('nintex_rpa_available_foxtrot_licenses', models.PositiveIntegerField(default=0, help_text='Specify the total number of available Foxtrot licenses in the path. IMPORTANT: Only applies to the Concurrent Edition license model.', verbose_name='Available Foxtrot licenses')),
                ('nintex_rpa_available_foxbot_licenses', models.PositiveIntegerField(default=0, help_text='Specify the total number of available FoxBot licenses in the path. IMPORTANT: Only applies to the Concurrent Edition license model.', verbose_name='Available FoxBot licenses')),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical bot',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalApp',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('name', models.CharField(db_index=True, help_text='Specify the name of the application.', max_length=255)),
                ('path', models.CharField(help_text='Specify the path to the application.', max_length=255)),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical app',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalApiTrigger',
            fields=[
                ('id', models.IntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(blank=True, editable=False)),
                ('date_updated', models.DateTimeField(blank=True, editable=False)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('app', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the application for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.App')),
                ('bot', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the bot for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(blank=True, db_constraint=False, help_text='Select the botflow for this trigger.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='orchestrator.Botflow')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical API trigger',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='FileTrigger',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('folder_in', models.CharField(help_text='Specify the folder for incoming files. When a file is detected in this folder, the trigger will be activated.', max_length=255)),
                ('folder_out', models.CharField(help_text='Specify the folder that the files should be moved to. When the trigger is activated, the file will be moved to this folder.', max_length=255)),
                ('filter', models.CharField(default='*', help_text="Specify any filter to only trigger on certain files. The default value '*' means all files. To specify multiple filters, use comma to separate them like this: '*.txt, *.pdf'.", max_length=255)),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('run_after', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active after this time.', null=True)),
                ('run_until', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active before this time.', null=True)),
                ('run_on_week_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on week days.')),
                ('run_on_weekend_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on weekend days.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
                ('app', models.ForeignKey(help_text='Select the application for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.App')),
                ('bot', models.ForeignKey(help_text='Select the bot for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(help_text='Select the botflow for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Botflow')),
            ],
        ),
        migrations.CreateModel(
            name='EmailOutlookTrigger',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('email', models.CharField(default='Default', help_text="Specify the email of the account to monitor. IMPORTANT: If you wish to monitor the primary Outlook account, the email should be set to 'Default'.", max_length=255)),
                ('folder_in', models.CharField(help_text="Specify the folder for incoming emails. When an email is detected in this folder, the trigger will be activated. The folder must be in the 'INBOX'. To specify subfolders, use slash to separate the folder names like this: Invoices/Incoming", max_length=255)),
                ('folder_out', models.CharField(help_text="Specify the folder that the emails should be moved to. When the trigger is activated, the email will be moved to this folder. The folder must be in the 'INBOX'. To specify subfolders, use slash to separate the folder names like this: Invoices/Incoming/Handled", max_length=255)),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('run_after', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active after this time.', null=True)),
                ('run_until', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active before this time.', null=True)),
                ('run_on_week_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on week days.')),
                ('run_on_weekend_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on weekend days.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
                ('app', models.ForeignKey(help_text='Select the application for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.App')),
                ('bot', models.ForeignKey(help_text='Select the bot for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(help_text='Select the botflow for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Botflow')),
            ],
            options={
                'verbose_name': 'Email Outlook trigger',
                'verbose_name_plural': 'Email Outlook triggers',
            },
        ),
        migrations.CreateModel(
            name='EmailImapTrigger',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('email', models.EmailField(help_text='Specify the email of the IMAP account.', max_length=254)),
                ('password', fernet_fields.fields.EncryptedCharField(help_text='Specify the password of the IMAP account.', max_length=255)),
                ('server', models.CharField(help_text='Specify the server of the IMAP account. For example: outlook.office365.com', max_length=255)),
                ('port', models.PositiveIntegerField(help_text='Specify the port of the IMAP account. For example: 993')),
                ('tls', models.BooleanField(default=True, help_text="Specify whether the IMAP account requires 'SSL/TLS'.", verbose_name='SSL/TLS')),
                ('folder_in', models.CharField(help_text="Specify the folder for incoming emails. When an email is detected in this folder, the trigger will be activated. The folder must be in the 'INBOX'. To specify subfolders, use slash to separate the folder names like this: Invoices/Incoming", max_length=255)),
                ('folder_out', models.CharField(help_text="Specify the folder that the emails should be moved to. When the trigger is activated, the email will be moved to this folder. The folder must be in the 'INBOX'. To specify subfolders, use slash to separate the folder names like this: Invoices/Incoming/Handled", max_length=255)),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('run_after', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active after this time.', null=True)),
                ('run_until', models.TimeField(blank=True, help_text='Specify a time to limit the trigger to only be active before this time.', null=True)),
                ('run_on_week_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on week days.')),
                ('run_on_weekend_days', models.BooleanField(default=True, help_text='Specify whether the trigger should be active on weekend days.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
                ('app', models.ForeignKey(help_text='Select the application for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.App')),
                ('bot', models.ForeignKey(help_text='Select the bot for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(help_text='Select the botflow for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Botflow')),
            ],
            options={
                'verbose_name': 'Email IMAP trigger',
                'verbose_name_plural': 'Email IMAP triggers',
            },
        ),
        migrations.CreateModel(
            name='ApiTrigger',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('activated', models.BooleanField(default=False, help_text='Specify whether the trigger should be active.')),
                ('status', models.CharField(default='Working', editable=False, help_text='Indicates the status of the trigger.', max_length=255)),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
                ('app', models.ForeignKey(help_text='Select the application for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.App')),
                ('bot', models.ForeignKey(help_text='Select the bot for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Bot')),
                ('botflow', models.ForeignKey(help_text='Select the botflow for this trigger.', on_delete=django.db.models.deletion.PROTECT, to='orchestrator.Botflow')),
            ],
            options={
                'verbose_name': 'API trigger',
                'verbose_name_plural': 'API triggers',
            },
        ),
    ]
